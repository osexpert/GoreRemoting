use public static Marshaller<T> Create<T>(Action<T, SerializationContext> serializer, Func<DeserializationContext, T> deserializer)
and instead of byte[] messages, use a eg.
IGorializer as send message (RequestMessage). rename IGorializer -> IRequestMessage? Or inherit ifaces?
Then in the marshaller convert from object to bytes.In case it is probably important that StreamResponseQueue is sync (1 item)
since we are queing live objects instead of byte[].
class ResponseMessage:MethodCallMessage\DelegateResultMessage\WireResponseMessage
maybe can have a class with an enum and these 3 (enum tell which one it is)


lz4
zstd
deflate
gzip

compress if over 1000 bytes?



    info.AddValue("ClassName", GetClassName(), typeof(string)); // Do not rename (binary serialization)
            info.AddValue("Message", _message, typeof(string)); // Do not rename (binary serialization)
            info.AddValue("Data", _data, typeof(IDictionary)); // Do not rename (binary serialization)
            info.AddValue("InnerException", _innerException, typeof(Exception)); // Do not rename (binary serialization)
            info.AddValue("HelpURL", _helpURL, typeof(string)); // Do not rename (binary serialization)
            info.AddValue("StackTraceString", SerializationStackTraceString, typeof(string)); // Do not rename (binary serialization)
            info.AddValue("RemoteStackTraceString", _remoteStackTraceString, typeof(string)); // Do not rename (binary serialization)
            info.AddValue("RemoteStackIndex", 0, typeof(int)); // Do not rename (binary serialization)
            info.AddValue("ExceptionMethod", null, typeof(string)); // Do not rename (binary serialization)
            info.AddValue("HResult", _HResult); // Do not rename (binary serialization)
            info.AddValue("Source", _source, typeof(string)); // Do not rename (binary serialization)
            info.AddValue("WatsonBuckets", SerializationWatsonBuckets, typeof(byte[])); // Do not rename (binary serialization)
        }
       protected Exception(SerializationInfo info, StreamingContext context)
        {
            if (info == null)
                throw new ArgumentNullException(nameof(info));

            _message = info.GetString("Message"); // Do not rename (binary serialization)
            _data = (IDictionary?)(info.GetValueNoThrow("Data", typeof(IDictionary))); // Do not rename (binary serialization)
            _innerException = (Exception?)(info.GetValue("InnerException", typeof(Exception))); // Do not rename (binary serialization)
            _helpURL = info.GetString("HelpURL"); // Do not rename (binary serialization)
            _stackTraceString = info.GetString("StackTraceString"); // Do not rename (binary serialization)
            _remoteStackTraceString = info.GetString("RemoteStackTraceString"); // Do not rename (binary serialization)
            _HResult = info.GetInt32("HResult"); // Do not rename (binary serialization)
            _source = info.GetString("Source"); // Do not rename (binary serialization)

            RestoreRemoteStackTrace(info, context);
        }
        
special ctor for exceptions?
has to be serializable?
Check this: StreamJsonRpc 

security: check that types are of same types in service methods?
so would loop methods with same name and same numer of args. Then check if types sent match those types,
and only then deserialize to real type.
BUT is this really a problem for json and memorypack etc? I dont think so...


remote linq
https://github.com/dotnet/csharplang/discussions/5555#discussioncomment-1852834
https://github.com/6bee/Remote.Linq

callcontext vs headers \ trailers of grpc?

meaning, could we make a GrpgCallHeaders static class, that works similar?
and meaning, could we make a GrpgCallTrailers static class, that works similar?



Use headers to tell what\if compression to use? Compress\compressor: Deflate, gzip, etc.

Use separate methods for bidir and unary? So if no callback delegate arguments can use unary.
Why? maybe a bit faster? But not sure.

TODO: try to reproduce mass reset\cancellation hang on client with bidir and dornet client?

grpd-dotnet server hack to close stream on return:

var ctx = context.GetHttpContext();
var http2stream = ctx.Features.Get<IHttp2StreamIdFeature>();
http2stream.GetType().GetMethod("OnEndStreamReceived", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance).Invoke(http2stream, null);

PS: only seems to work well for native client.
dotnet client at some point hang due to a mass reset problem (also it is a huge overhead here that every call end upm as cancelled)

So...it seems not possible to create a grpc dotnet server that is stable with both native and dotnet client...
Native client and server is always stable. Native server is stable with dotnet client too.

Dotnet client can be made stable with dotnetserver by having server sering a hangup message to the client
and then client call RequestStream.CompleteAsync() before the server call returns.
BUT this does not help when using the native client -> dotnet server, in this case the dot net server still fails.
So native client -> dotnet server seems to be most incompatible and no know hack or workaround here.

TODO: compression. use headers? (Metadata). Compress if over 1000 bytes? (at least good for data over web sockets). Deflate
But grpc has native compression too? Is it enabled by default? Find out...



