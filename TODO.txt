Intern strings like vs-streamjsonrpc? For messagepack.

Security?
During desser, somehow validate that the types sent match the signature of the method called?
If a method take object as arg, then its pointless off course, all will pass.
It is not easy to reach the method sig\types in the code that desser (for MessagePack nor possible at all since it happens within the library).
But I am not sure if this is a security problem. The only bad thing you can do is to serialize things that will fail to be used as argument
for target method, but I guess it would be better to detect this before deserialize of the type,
but it depends on, what bad thing can really happen by deserialize random types?
For binary formatter it is bad, but this is because the way to creates the objects, using reflection to call ctors.
Other serializers I don't think have these problems, so the harm you can do with them...I think it theoretical.
Anyways...this is all based on BinaryFormatter and migrating away from it, so security is not the main point here.
When all is migrated away from BinaryFormatter to some other formatter, then you could must easier switch the transport too.

CallContext
ResultContext? Maybe an idea to separate them, have a separate context that flows back to the client...


session:

client heartbeat
client login\Auth

// ret sessionId
Guid service.Auth()

token?
sessionid?


TODO:
Maybe OneWay delegate could be an opt-in instead of the default (still only max one could be non-OneWay)
Instead of eating exceptions from delegates, maybe could have an optino to throw them or some way to get notified about them (via subscribe to delegate)
Update: there is an event OneWayException in RemotingClient\RemotingServer if you want to observe any eaten exceptions.
Add session management? (not in the core, but as example)

SessionManager? And an easyer way to send messages to clients via session manager?

Cache created methods? MakeGenericType? MakeGenericMethod?
CreateProxiedDelegate?
_delegateProxyCache?

OnBefore(Method)Call
OnAfter(Method)Call
OnOneWayException
OnUnobservedException
OnException
OnClientTriggeredException


    info.AddValue("ClassName", GetClassName(), typeof(string)); // Do not rename (binary serialization)
            info.AddValue("Message", _message, typeof(string)); // Do not rename (binary serialization)
            info.AddValue("Data", _data, typeof(IDictionary)); // Do not rename (binary serialization)
            info.AddValue("InnerException", _innerException, typeof(Exception)); // Do not rename (binary serialization)
            info.AddValue("HelpURL", _helpURL, typeof(string)); // Do not rename (binary serialization)
            info.AddValue("StackTraceString", SerializationStackTraceString, typeof(string)); // Do not rename (binary serialization)
            info.AddValue("RemoteStackTraceString", _remoteStackTraceString, typeof(string)); // Do not rename (binary serialization)
            info.AddValue("RemoteStackIndex", 0, typeof(int)); // Do not rename (binary serialization)
            info.AddValue("ExceptionMethod", null, typeof(string)); // Do not rename (binary serialization)
            info.AddValue("HResult", _HResult); // Do not rename (binary serialization)
            info.AddValue("Source", _source, typeof(string)); // Do not rename (binary serialization)
            info.AddValue("WatsonBuckets", SerializationWatsonBuckets, typeof(byte[])); // Do not rename (binary serialization)
        }
       protected Exception(SerializationInfo info, StreamingContext context)
        {
            if (info == null)
                throw new ArgumentNullException(nameof(info));

            _message = info.GetString("Message"); // Do not rename (binary serialization)
            _data = (IDictionary?)(info.GetValueNoThrow("Data", typeof(IDictionary))); // Do not rename (binary serialization)
            _innerException = (Exception?)(info.GetValue("InnerException", typeof(Exception))); // Do not rename (binary serialization)
            _helpURL = info.GetString("HelpURL"); // Do not rename (binary serialization)
            _stackTraceString = info.GetString("StackTraceString"); // Do not rename (binary serialization)
            _remoteStackTraceString = info.GetString("RemoteStackTraceString"); // Do not rename (binary serialization)
            _HResult = info.GetInt32("HResult"); // Do not rename (binary serialization)
            _source = info.GetString("Source"); // Do not rename (binary serialization)

            RestoreRemoteStackTrace(info, context);
        }
        
special ctor for exceptions?
has to be serializable?
Check this: StreamJsonRpc 

security: check that types are of same types in service methods?
so would loop methods with same name and same numer of args. Then check if types sent match those types,
and only then deserialize to real type.
BUT is this really a problem for json and memorypack etc? I dont think so...


remote linq
https://github.com/dotnet/csharplang/discussions/5555#discussioncomment-1852834
https://github.com/6bee/Remote.Linq

callcontext vs headers \ trailers of grpc?

meaning, could we make a GrpgCallHeaders static class, that works similar?
and meaning, could we make a GrpgCallTrailers static class, that works similar?



Use headers to tell what\if compression to use? Compress\compressor: Deflate, gzip, etc.

Use separate methods for bidir and unary? So if no callback delegate arguments can use unary.
Why? maybe a bit faster? But not sure.

TODO: try to reproduce mass reset\cancellation hang on client with bidir and dornet client?

grpd-dotnet server hack to close stream on return:

var ctx = context.GetHttpContext();
var http2stream = ctx.Features.Get<IHttp2StreamIdFeature>();
http2stream.GetType().GetMethod("OnEndStreamReceived", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance).Invoke(http2stream, null);

PS: only seems to work well for native client.
dotnet client at some point hang due to a mass reset problem (also it is a huge overhead here that every call end upm as cancelled)

So...it seems not possible to create a grpc dotnet server that is stable with both native and dotnet client...
Native client and server is always stable. Native server is stable with dotnet client too.

Dotnet client can be made stable with dotnetserver by having server sering a hangup message to the client
and then client call RequestStream.CompleteAsync() before the server call returns.
BUT this does not help when using the native client -> dotnet server, in this case the dot net server still fails.
So native client -> dotnet server seems to be most incompatible and no know hack or workaround here.

TODO: compression. use headers? (Metadata). Compress if over 1000 bytes? (at least good for data over web sockets). Deflate
But grpc has native compression too? Is it enabled by default? Find out...



