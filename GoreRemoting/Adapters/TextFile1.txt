using System.Threading.Channels;
namespace GoreRemoting;

public static class AsyncEnumerabler
{
	public static IAsyncEnumerable<T> FromPush<T>(
		Func<Func<T, Task>, Task> dataSource,
		int? queueLimit = null,
		CancellationToken cancel = default
		)
	{
		return new PushAsyncEnumerable<T>(dataSource, queueLimit, cancel, useCancellationToken: false);
	}

	public static IAsyncEnumerable<T> FromPush<T>(
		Func<Func<T, Task>, CancellationToken, Task> dataSource,
		int? queueLimit = null,
		CancellationToken cancel = default
		)
	{
		return new PushAsyncEnumerable<T>(dataSource, queueLimit, cancel, useCancellationToken: true);
	}

	private static Channel<TT> CreateChannel<TT>(int? queueLimit)
	{
		if (queueLimit == null)
		{
			return Channel.CreateUnbounded<TT>(new UnboundedChannelOptions
			{
				SingleWriter = false,
				SingleReader = true,
			});
		}
		else
		{
			return Channel.CreateBounded<TT>(new BoundedChannelOptions(queueLimit.Value)
			{
				SingleWriter = false,
				SingleReader = true
			});
		}
	}

	private class PushAsyncEnumerable<T> : IAsyncEnumerable<T>
	{
		private readonly object _dataSource;
		private readonly int? _queueLimit;
		private readonly CancellationToken _cancel;
		private readonly bool _useCancellationToken;

		public PushAsyncEnumerable(object dataSource, int? queueLimit, CancellationToken cancel, bool useCancellationToken)
		{
			_dataSource = dataSource;
			_queueLimit = queueLimit;
			_cancel = cancel;
			_useCancellationToken = useCancellationToken;
		}

		public IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default)
		{
			var channel = AsyncEnumerabler.CreateChannel<T>(_queueLimit);
			var cts = CancellationTokenSource.CreateLinkedTokenSource(_cancel, cancellationToken);

			async Task ForwardAsync()
			{
				try
				{
					if (_useCancellationToken)
					{
						var dataSourceWithCancel = (Func<Func<T, Task>, CancellationToken, Task>)_dataSource;
						await dataSourceWithCancel(data => channel.Writer.WriteAsync(data, cts.Token).AsTask(), cts.Token).ConfigureAwait(false);
					}
					else
					{
						var dataSourceNoCancel = (Func<Func<T, Task>, Task>)_dataSource;
						await dataSourceNoCancel(data => channel.Writer.WriteAsync(data, cts.Token).AsTask()).ConfigureAwait(false);
					}
					channel.Writer.Complete();
				}
				catch (Exception e)
				{
					channel.Writer.TryComplete(e);
				}
			}

			_ = ForwardAsync();
			return new PushAsyncEnumerator<T>(channel.Reader, cts);
		}
	}

	private class PushAsyncEnumerator<T> : IAsyncEnumerator<T>
	{
		private readonly ChannelReader<T> _reader;
		private readonly CancellationTokenSource _cts;

		public T Current { get; private set; }

		public PushAsyncEnumerator(ChannelReader<T> reader, CancellationTokenSource cts)
		{
			_reader = reader;
			_cts = cts;
		}

		public async ValueTask<bool> MoveNextAsync()
		{
			if (await _reader.WaitToReadAsync(_cts.Token).ConfigureAwait(false))
			{
				Current = await _reader.ReadAsync(_cts.Token).ConfigureAwait(false);
				return true;
			}
			return false;
		}

		public async ValueTask DisposeAsync()
		{
			_cts.Cancel();
			_cts.Dispose();
		}
	}
}

public static class AsyncEnumerableExtensions
{
	public static async Task Push<T>(
		this IAsyncEnumerable<T> source,
		Func<T, Task> action,
		CancellationToken cancel = default
		)
	{
		await foreach (var item in source.WithCancellation(cancel).ConfigureAwait(false))
		{
			await action(item).ConfigureAwait(false);
		}
	}
}


private class PushAsyncEnumerable<T> : IAsyncEnumerable<T>
{
    // ... existing code ...

    public IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default)
    {
        var channel = AsyncEnumerabler.CreateChannel<T>(_queueLimit);
        var cts = CancellationTokenSource.CreateLinkedTokenSource(_cancel, cancellationToken);

        async Task ForwardAsync()
        {
            try
            {
                if (_useCancellationToken)
                {
                    var dataSourceWithCancel = (Func<Func<T, Task>, CancellationToken, Task>)_dataSource;
                    await dataSourceWithCancel(data => channel.Writer.WriteAsync(data, cts.Token).AsTask(), cts.Token).ConfigureAwait(false);
                }
                else
                {
                    var dataSourceNoCancel = (Func<Func<T, Task>, Task>)_dataSource;
                    await dataSourceNoCancel(data => channel.Writer.WriteAsync(data, cts.Token).AsTask()).ConfigureAwait(false);
                }
                channel.Writer.Complete();
            }
            catch (Exception e)
            {
                channel.Writer.TryComplete(e);
            }
        }

        // Start on first MoveNextAsync call instead of immediately
        var started = false;
        return new PushAsyncEnumerator<T>(channel.Reader, cts, ForwardAsync, () => 
        {
            if (!started)
            {
                started = true;
                _ = ForwardAsync();
            }
        });
    }
}

private class PushAsyncEnumerator<T> : IAsyncEnumerator<T>
{
    private readonly ChannelReader<T> _reader;
    private readonly CancellationTokenSource _cts;
    private readonly Action _onFirstMove;

    public T Current { get; private set; }

    public PushAsyncEnumerator(ChannelReader<T> reader, CancellationTokenSource cts, Action onFirstMove)
    {
        _reader = reader;
        _cts = cts;
        _onFirstMove = onFirstMove;
    }

    public async ValueTask<bool> MoveNextAsync()
    {
        _onFirstMove?.Invoke();
        _onFirstMove = null; // Only call once

        if (await _reader.WaitToReadAsync(_cts.Token).ConfigureAwait(false))
        {
            Current = await _reader.ReadAsync(_cts.Token).ConfigureAwait(false);
            return true;
        }
        return false;
    }

    public async ValueTask DisposeAsync()
    {
        _cts.Cancel();
        _cts.Dispose();
    }
}